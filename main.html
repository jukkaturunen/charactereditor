<script>
let character_edited = false;
let characterData = null;
let currentCharacterFile = null;
let conditionsData = {};

function setEdited() {
    character_edited = true;
    document.getElementById('save-changes-link').classList.remove('hidden');
    document.getElementById('status-up-to-date').classList.add('hidden');
}

function setUpToDate() {
    character_edited = false;
    document.getElementById('save-changes-link').classList.add('hidden');
    document.getElementById('status-up-to-date').classList.remove('hidden');
}

function saveChanges() {
    if (!characterData || !currentCharacterFile) {
        alert('No character loaded to save.');
        return false;
    }

    const meritsEditor = document.getElementById('merits-editor');
    if (meritsEditor && meritsEditor.is_valid()) {
        characterData.character.merits = meritsEditor.json_value;

        // Show saving state
        const saveLink = document.getElementById('save-changes-link');
        const originalText = saveLink.textContent;
        saveLink.innerHTML = '<div class="loading-text">Saving<div class="spinner-skull">ðŸ’€</div></div>';
        saveLink.style.pointerEvents = 'none';

        google.script.run
            .withSuccessHandler(function(result) {
                // Restore save link
                saveLink.textContent = originalText;
                saveLink.style.pointerEvents = 'auto';

                if (result.success) {
                    setUpToDate();
                } else {
                    alert('Error saving character: ' + result.error);
                }
            })
            .withFailureHandler(function(error) {
                // Restore save link
                saveLink.textContent = originalText;
                saveLink.style.pointerEvents = 'auto';
                alert('Error saving character: ' + error.toString());
            })
            .saveCharacter(currentCharacterFile.id, JSON.stringify(characterData, null, 2));
    } else {
        alert('Invalid JSON in Merits editor. Please fix it before saving.');
    }
    return false;
}

function setValueByPath(obj, path, value) {
    const keys = path.split('.');
    let current = obj;
    for (let i = 0; i < keys.length - 1; i++) {
        current = current[keys[i]];
    }

    // Convert numeric strings to numbers
    let convertedValue = value;
    if (typeof value === 'string' && !isNaN(value) && !isNaN(parseFloat(value)) && value.trim() !== '') {
        convertedValue = parseInt(value);
        // Use parseFloat if it's a decimal number
        if (value.includes('.')) {
            convertedValue = parseFloat(value);
        }
    }

    current[keys[keys.length - 1]] = convertedValue;
}

function saveHeaderEdit(buttonElement, dataPath) {
    const input = buttonElement.previousElementSibling;
    const newValue = input.value;
    setValueByPath(characterData.character, dataPath, newValue);
    setEdited();
    render();
}

function makeEditable(element, dataPath) {
    if (element.parentElement.querySelector('input')) return; // Already editing
    const currentValue = element.textContent;
    const parent = element.parentElement;
    const label = parent.firstElementChild.textContent;

    // Check if this is in the stats and xp section
    const isStatsOrXp = dataPath.includes('size') || dataPath.includes('speed') || dataPath.includes('defense') ||
                        dataPath.includes('armor') || dataPath.includes('initiative_mod') || dataPath.includes('experiences.total');

    const inputWidth = isStatsOrXp ? '20%' : '60%';
    const alignment = isStatsOrXp ? 'text-align: right;' : '';

    parent.innerHTML = `
        <span>${label}</span>
        <span style="${alignment}">
            <input type="text" value="${currentValue}" style="width: ${inputWidth};">
            <button onclick="saveHeaderEdit(this, '${dataPath}')">âœ“</button>
            <button onclick="render()">âœ—</button>
        </span>
    `;

    const input = parent.querySelector('input');
    input.focus();
    input.select();
}

function toggleSection(sectionId, toggleElement) {
    const section = document.getElementById(sectionId);
    section.classList.toggle('collapsed');

    if (section.classList.contains('collapsed')) {
        toggleElement.innerHTML = 'â–¶';
    } else {
        toggleElement.innerHTML = 'â–¼';
    }
}

function renderDots(category, subcategory, name, value, maxDots = 5) {
    let dotsHtml = '<div class="dots">';
    for (let i = 0; i < maxDots; i++) {
        const newValue = (i + 1 === value) ? 0 : i + 1;
        dotsHtml += `<div class="dot ${i < value ? 'filled' : ''}" onclick="updateValue('${category}', '${subcategory}', '${name}', ${newValue})"></div>`;
    }
    dotsHtml += '</div>';
    return dotsHtml;
}

let healthDamageState = [];

function renderBoxes(category, name, value, maxBoxes = 10, maxValue = null) {
    let boxesHtml = '<div class="boxes">';
    for (let i = 0; i < maxBoxes; i++) {
        const isActive = maxValue === null || i < maxValue;
        const newValue = (i + 1 === value) ? 0 : i + 1;

        if (isActive) {
            boxesHtml += `<div class="box ${i < value ? 'filled' : ''}" onclick="updateValue('${category}', '', '${name}', ${newValue})"></div>`;
        } else {
            boxesHtml += `<div class="box inactive"></div>`;
        }
    }
    boxesHtml += '</div>';
    return boxesHtml;
}

function renderHealthDamage(damageState, maxHealth) {
    let boxesHtml = '<div class="boxes">';
    damageState.forEach((damageType, index) => {
        // Determine if box is active (within max health) or inactive
        const isActive = index < maxHealth;

        // Determine penalty color for last 3 active boxes
        let penaltyClass = '';
        if (isActive) {
            const remainingActive = maxHealth - index;
            if (remainingActive === 3) penaltyClass = ' penalty-1'; // Yellow
            else if (remainingActive === 2) penaltyClass = ' penalty-2'; // Light orange
            else if (remainingActive === 1) penaltyClass = ' penalty-3'; // Darker orange/red
        }

        const boxClass = isActive ? `box${penaltyClass}` : 'box inactive';
        const clickHandler = isActive ? `onclick="updateHealthDamage(${index})"` : '';

        boxesHtml += `<div class="${boxClass}" ${clickHandler}>`;

        if (isActive) {
            switch (damageType) {
                case 1: // Bashing
                    boxesHtml += '<svg width="15" height="15"><line x1="0" y1="15" x2="15" y2="0" stroke="black" stroke-width="1"/></svg>';
                    break;
                case 2: // Lethal
                    boxesHtml += '<svg width="15" height="15"><line x1="0" y1="0" x2="15" y2="15" stroke="black" stroke-width="1"/><line x1="0" y1="15" x2="15" y2="0" stroke="black" stroke-width="1"/></svg>';
                    break;
                case 3: // Aggravated
                    boxesHtml += '<svg width="15" height="15"><line x1="0" y1="0" x2="15" y2="15" stroke="black" stroke-width="1"/><line x1="0" y1="15" x2="15" y2="0" stroke="black" stroke-width="1"/><line x1="7.5" y1="0" x2="7.5" y2="15" stroke="black" stroke-width="1"/><line x1="0" y1="7.5" x2="15" y2="7.5" stroke="black" stroke-width="1"/></svg>';
                    break;
            }
        }
        boxesHtml += '</div>';
    });
    boxesHtml += '</div>';
    return boxesHtml;
}

function updateHealthDamage(boxIndex) {
    setEdited();
    const currentDamageType = healthDamageState[boxIndex];
    const newDamageType = (currentDamageType + 1) % 4;
    healthDamageState[boxIndex] = newDamageType;

    recalculateDamageCounts();
}

function recalculateDamageCounts() {
    let bashing = 0;
    let lethal = 0;
    let aggravated = 0;

    for (const damageType of healthDamageState) {
        if (damageType === 1) bashing++;
        else if (damageType === 2) lethal++;
        else if (damageType === 3) aggravated++;
    }

    characterData.character.health.damage = { bashing, lethal, aggravated };
    render();
}

function updateValue(category, subcategory, name, newValue) {
    setEdited();

    if (category === 'beats' && newValue === 5) {
        characterData.character.beats = 0;
        // Ensure total is a number before adding to it
        characterData.character.experiences.total = parseInt(characterData.character.experiences.total) + 1;
    } else {
        if (subcategory) {
            characterData.character[category][subcategory][name] = newValue;
        } else if (name) {
            characterData.character[category][name] = newValue;
        } else {
            characterData.character[category] = newValue;
        }
    }

    render();
}

function addListItem(category) {
    if (category === 'specialties') {
        openSpecialtyModal();
    } else if (category === 'conditions') {
        openConditionModal();
    } else if (category === 'aspirations') {
        openAspirationModal();
    } else if (category === 'weapons') {
        openWeaponModal();
    } else if (category === 'equipment') {
        openEquipmentModal();
    } else {
        const singular = category.slice(0, -1);
        const newValue = prompt(`Enter new ${singular}:`);
        if (newValue) {
            characterData.character[category].push(newValue);
            setEdited();
            render();
        }
    }
}

// Global variable to store pending delete operation
let pendingDelete = null;

function deleteListItem(category, key) {
    // Store the delete operation for later execution
    pendingDelete = { category, key };

    // Set appropriate confirmation text based on category
    let itemName;
    if (category === 'specialties') {
        itemName = `specialty "${formatSkillName(key)}"`;
    } else if (category === 'weapons') {
        itemName = `weapon "${key}"`;
    } else if (category === 'conditions') {
        itemName = `condition "${characterData.character[category][key]}"`;
    } else if (category === 'aspirations') {
        itemName = `aspiration "${characterData.character[category][key]}"`;
    } else if (category === 'equipment') {
        itemName = `equipment "${characterData.character[category][key]}"`;
    } else {
        itemName = 'this item';
    }

    document.getElementById('delete-confirmation-text').textContent = `Are you sure you want to delete ${itemName}?`;
    document.getElementById('confirm-delete-modal').style.display = 'block';
}

function confirmDelete() {
    if (pendingDelete) {
        const { category, key } = pendingDelete;
        if (category === 'specialties' || category === 'weapons') {
            delete characterData.character[category][key];
        } else {
            characterData.character[category].splice(key, 1);
        }
        setEdited();
        render();
        closeDeleteModal();
    }
}

function closeDeleteModal() {
    document.getElementById('confirm-delete-modal').style.display = 'none';
    pendingDelete = null;
}

function openSpecialtyModal() {
    const modal = document.getElementById('specialty-modal');
    modal.style.display = 'block';
    populateSkillSelector();
}

function closeSpecialtyModal() {
    const modal = document.getElementById('specialty-modal');
    modal.style.display = 'none';
}

function openNewCharacterModal() {
    const modal = document.getElementById('new-character-modal');
    modal.style.display = 'block';
}

function closeNewCharacterModal() {
    const modal = document.getElementById('new-character-modal');
    modal.style.display = 'none';
    document.getElementById('new-character-name').value = '';
}

function populateSkillSelector() {
    const select = document.getElementById('skill-select');
    select.innerHTML = '';

    for (const category in characterData.character.skills) {
        const optgroup = document.createElement('optgroup');
        optgroup.label = capitalizeFirstLetter(category);
        for (const skill in characterData.character.skills[category]) {
            const option = document.createElement('option');
            option.value = skill;
            option.textContent = formatSkillName(skill);
            optgroup.appendChild(option);
        }
        select.appendChild(optgroup);
    }
}

function loadCharacterList() {
    console.log('loadCharacterList() called');

    google.script.run
        .withSuccessHandler(function(files) {
            console.log('Success handler called with files:', files);
            const selector = document.getElementById('character-selector');
            const loading = document.getElementById('loading');

            console.log('Selector element:', selector);
            console.log('Loading element:', loading);

            selector.innerHTML = '<option value="" disabled selected>Select a character</option>';

            console.log('Number of files received:', files.length);
            files.forEach(function(file, index) {
                console.log(`Processing file ${index}:`, file);
                const option = document.createElement('option');
                option.value = file.id;
                option.textContent = file.name.replace('.json', '');
                selector.appendChild(option);
            });

            loading.style.display = 'none';
            selector.disabled = false;
            console.log('Character list loading completed successfully');
        })
        .withFailureHandler(function(error) {
            console.error('Error in loadCharacterList:', error);
            document.getElementById('loading').textContent = 'Error loading characters: ' + error.toString();
        })
        .getCharacterFiles();
}

function loadCharacter(fileId) {
    // Show loading state
    const loadBtn = document.getElementById('load-character-btn');
    const originalText = loadBtn.textContent;
    loadBtn.innerHTML = '<div class="loading-text">Loading<div class="spinner"></div></div>';
    loadBtn.disabled = true;

    google.script.run
        .withSuccessHandler(function(result) {
            // Hide loading state
            loadBtn.textContent = originalText;
            loadBtn.disabled = false;

            if (result.success) {
                characterData = JSON.parse(result.data);
                currentCharacterFile = { id: fileId };

                document.getElementById('character-sheet').classList.add('visible');
                document.body.classList.add('character-loaded');
                setUpToDate();

                healthDamageState = []; // Reset health damage state
                render();
            } else {
                alert('Error loading character: ' + result.error);
            }
        })
        .withFailureHandler(function(error) {
            // Hide loading state
            loadBtn.textContent = originalText;
            loadBtn.disabled = false;
            alert('Error loading character: ' + error.toString());
        })
        .loadCharacter(fileId);
}

function createNewCharacter() {
    const name = document.getElementById('new-character-name').value.trim();
    if (!name) {
        alert('Please enter a character name.');
        return;
    }

    const newCharacterData = {
        "character": {
            "name": name,
            "age": "",
            "player": "",
            "concept": "",
            "virtue": "",
            "vice": "",
            "chronicle": "",
            "faction": "",
            "group_name": "",
            "attributes": {
                "mental": {
                    "intelligence": 1,
                    "wits": 1,
                    "resolve": 1
                },
                "physical": {
                    "strength": 1,
                    "dexterity": 1,
                    "stamina": 1
                },
                "social": {
                    "presence": 1,
                    "manipulation": 1,
                    "composure": 1
                }
            },
            "skills": {
                "mental": {
                    "academics": 0,
                    "computer": 0,
                    "crafts": 0,
                    "investigation": 0,
                    "medicine": 0,
                    "occult": 0,
                    "politics": 0,
                    "science": 0
                },
                "physical": {
                    "athletics": 0,
                    "brawl": 0,
                    "drive": 0,
                    "firearms": 0,
                    "larceny": 0,
                    "stealth": 0,
                    "survival": 0,
                    "weaponry": 0
                },
                "social": {
                    "animal_ken": 0,
                    "empathy": 0,
                    "expression": 0,
                    "intimidation": 0,
                    "persuasion": 0,
                    "socialize": 0,
                    "streetwise": 0,
                    "subterfuge": 0
                }
            },
            "specialties": {},
            "merits": {},
            "health": {
                "max": 7,
                "damage": {
                    "bashing": 0,
                    "lethal": 0,
                    "aggravated": 0
                }
            },
            "willpower": {
                "max": 5,
                "current": 5
            },
            "integrity": 7,
            "size": 5,
            "speed": 9,
            "defense": 2,
            "armor": 0,
            "initiative_mod": 5,
            "beats": 0,
            "experiences": {
                "total": 0,
                "gained from": {},
                "spent on": {}
            },
            "conditions": [],
            "aspirations": [],
            "equipment": [],
            "weapons": {},
            "vehicles": {},
            "breaking_points": [],
            "history": [],
            "goals": [],
            "description": {
                "age": "",
                "date_of_birth": "",
                "hair": "",
                "eyes": "",
                "race": "",
                "nationality": "",
                "height": "",
                "weight": "",
                "sex": "",
                "distinguishing_characteristics": ""
            }
        }
    };

    google.script.run
        .withSuccessHandler(function(result) {
            if (result.success) {
                closeNewCharacterModal();
                loadCharacterList(); // Refresh the character list
                alert('New character created successfully!');

                // Load the new character automatically
                setTimeout(() => {
                    const selector = document.getElementById('character-selector');
                    selector.value = result.fileId;
                    loadCharacter(result.fileId);
                }, 500);
            } else {
                alert('Error creating character: ' + result.error);
            }
        })
        .withFailureHandler(function(error) {
            alert('Error creating character: ' + error.toString());
        })
        .createNewCharacter(name, JSON.stringify(newCharacterData, null, 2));
}

document.addEventListener('DOMContentLoaded', () => {
    console.log('DOMContentLoaded event fired');
    // Load character list on page load
    console.log('About to call loadCharacterList');
    loadCharacterList();

    // Specialty modal handlers
    const specialtyModal = document.getElementById('specialty-modal');
    const specialtyCloseButton = specialtyModal.querySelector('.close-button');
    const saveSpecialtyButton = specialtyModal.querySelector('#save-specialty-btn');
    const cancelSpecialtyButton = specialtyModal.querySelector('#cancel-specialty-btn');

    specialtyCloseButton.onclick = closeSpecialtyModal;
    cancelSpecialtyButton.onclick = closeSpecialtyModal;

    saveSpecialtyButton.onclick = () => {
        const skill = document.getElementById('skill-select').value;
        const specialty = document.getElementById('specialty-input').value;
        if (skill && specialty) {
            characterData.character.specialties[skill] = specialty;
            setEdited();
            render();
            closeSpecialtyModal();
        }
    };

    // Condition modal handlers
    const conditionModal = document.getElementById('condition-modal');
    const conditionCloseButton = conditionModal.querySelector('.close-button');
    const addConditionButton = conditionModal.querySelector('#add-condition-btn');
    const cancelConditionButton = conditionModal.querySelector('#cancel-condition-btn');
    const conditionSelect = document.getElementById('condition-select');

    conditionCloseButton.onclick = closeConditionModal;
    cancelConditionButton.onclick = closeConditionModal;
    addConditionButton.onclick = addSelectedCondition;

    conditionSelect.addEventListener('change', () => {
        const selectedCondition = conditionSelect.value;
        displayConditionInfo(selectedCondition);
    });

    // Aspiration modal handlers
    const aspirationModal = document.getElementById('aspiration-modal');
    const aspirationCloseButton = aspirationModal.querySelector('.close-button');
    const addAspirationButton = aspirationModal.querySelector('#add-aspiration-btn');
    const cancelAspirationButton = aspirationModal.querySelector('#cancel-aspiration-btn');
    const aspirationInput = document.getElementById('aspiration-input');

    aspirationCloseButton.onclick = closeAspirationModal;
    cancelAspirationButton.onclick = closeAspirationModal;
    addAspirationButton.onclick = addAspiration;

    // Allow Enter key to add aspiration
    aspirationInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addAspiration();
        }
    });

    // Weapon modal handlers
    const weaponModal = document.getElementById('weapon-modal');
    const weaponCloseButton = weaponModal.querySelector('.close-button');
    const addWeaponButton = weaponModal.querySelector('#add-weapon-btn');
    const cancelWeaponButton = weaponModal.querySelector('#cancel-weapon-btn');
    const weaponSelect = document.getElementById('weapon-select');

    weaponCloseButton.onclick = closeWeaponModal;
    cancelWeaponButton.onclick = closeWeaponModal;
    addWeaponButton.onclick = addSelectedWeapon;

    weaponSelect.addEventListener('change', () => {
        const selectedWeapon = weaponSelect.value;
        displayWeaponInfo(selectedWeapon);
    });

    // Delete confirmation modal handlers
    const deleteModal = document.getElementById('confirm-delete-modal');
    const deleteCloseButton = deleteModal.querySelector('.close-button');
    const confirmDeleteButton = document.getElementById('confirm-delete-btn');
    const cancelDeleteButton = document.getElementById('cancel-delete-btn');

    deleteCloseButton.onclick = closeDeleteModal;
    cancelDeleteButton.onclick = closeDeleteModal;
    confirmDeleteButton.onclick = confirmDelete;

    // Equipment modal handlers
    const equipmentModal = document.getElementById('equipment-modal');
    const equipmentCloseButton = equipmentModal.querySelector('.close-button');
    const addEquipmentButton = equipmentModal.querySelector('#add-equipment-btn');
    const cancelEquipmentButton = equipmentModal.querySelector('#cancel-equipment-btn');
    const equipmentInput = document.getElementById('equipment-input');

    equipmentCloseButton.onclick = closeEquipmentModal;
    cancelEquipmentButton.onclick = closeEquipmentModal;
    addEquipmentButton.onclick = addEquipment;

    // Allow Enter key to add equipment
    equipmentInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addEquipment();
        }
    });

    // Experience modal handlers
    const experienceModal = document.getElementById('experience-modal');
    const experienceCloseButton = experienceModal.querySelector('.close-button');
    const addSpentXpButton = experienceModal.querySelector('#add-spent-xp-btn');
    const cancelExperienceButton = experienceModal.querySelector('#cancel-experience-btn');
    const spentOnInput = document.getElementById('xp-spent-on-input');
    const amountInput = document.getElementById('xp-amount-input');

    experienceCloseButton.onclick = closeExperienceModal;
    cancelExperienceButton.onclick = closeExperienceModal;
    addSpentXpButton.onclick = addSpentXp;

    // Allow Enter key to add spent XP
    spentOnInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            amountInput.focus();
        }
    });

    amountInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addSpentXp();
        }
    });

    // Breaking points modal handlers
    const breakingPointsModal = document.getElementById('breaking-points-modal');
    const breakingPointsCloseButton = breakingPointsModal.querySelector('.close-button');
    const addBreakingPointButton = breakingPointsModal.querySelector('#add-breaking-point-btn');
    const cancelBreakingPointsButton = breakingPointsModal.querySelector('#cancel-breaking-points-btn');
    const breakingPointInput = document.getElementById('breaking-point-input');

    breakingPointsCloseButton.onclick = closeBreakingPointsModal;
    cancelBreakingPointsButton.onclick = closeBreakingPointsModal;
    addBreakingPointButton.onclick = addBreakingPoint;

    // Allow Enter key to add breaking point
    breakingPointInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addBreakingPoint();
        }
    });

    // New character modal handlers
    const newCharacterModal = document.getElementById('new-character-modal');
    const newCharacterCloseButton = newCharacterModal.querySelector('.close-button');
    const createCharacterButton = newCharacterModal.querySelector('#create-character-btn');
    const cancelNewCharacterButton = newCharacterModal.querySelector('#cancel-new-character-btn');

    newCharacterCloseButton.onclick = closeNewCharacterModal;
    cancelNewCharacterButton.onclick = closeNewCharacterModal;
    createCharacterButton.onclick = createNewCharacter;

    // Character selector and load button
    const characterSelector = document.getElementById('character-selector');
    const loadCharacterBtn = document.getElementById('load-character-btn');
    const newCharacterBtn = document.getElementById('new-character-btn');

    if (characterSelector && loadCharacterBtn) {
        characterSelector.addEventListener('change', () => {
            if (characterSelector.value) {
                loadCharacterBtn.disabled = false;
            } else {
                loadCharacterBtn.disabled = true;
            }
        });

        loadCharacterBtn.addEventListener('click', () => {
            const selectedCharacter = characterSelector.value;
            if (selectedCharacter) {
                loadCharacter(selectedCharacter);
            }
        });
    }

    if (newCharacterBtn) {
        newCharacterBtn.addEventListener('click', openNewCharacterModal);
    }

    // Close modals when clicking outside
    window.onclick = (event) => {
        if (event.target == specialtyModal) {
            closeSpecialtyModal();
        } else if (event.target == conditionModal) {
            closeConditionModal();
        } else if (event.target == aspirationModal) {
            closeAspirationModal();
        } else if (event.target == weaponModal) {
            closeWeaponModal();
        } else if (event.target == deleteModal) {
            closeDeleteModal();
        } else if (event.target == equipmentModal) {
            closeEquipmentModal();
        } else if (event.target == experienceModal) {
            closeExperienceModal();
        } else if (event.target == breakingPointsModal) {
            closeBreakingPointsModal();
        } else if (event.target == newCharacterModal) {
            closeNewCharacterModal();
        }
    };

    // Initialize merits editor event listener
    const meritsEditor = document.getElementById('merits-editor');
    if (meritsEditor) {
        meritsEditor.addEventListener('keyup', () => {
            if (meritsEditor.is_valid()) {
                setEdited();
            }
        });
    }
});

function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function formatSkillName(name) {
    const withSpaces = name.replace(/_/g, ' ');
    return capitalizeFirstLetter(withSpaces);
}

function populateSpecialties(specialties) {
    const specialtiesEl = document.getElementById('specialties-content');
    specialtiesEl.innerHTML = '<h3>Specialties</h3>';
    for (const skill in specialties) {
        const specialty = specialties[skill];
        specialtiesEl.innerHTML += `<div class="item"><span>${formatSkillName(skill)}</span><div class="specialty-item-right"><span>${specialty}</span><span class="delete-icon" onclick="deleteListItem('specialties', '${skill}')">ðŸ—‘</span></div></div>`;
    }
    specialtiesEl.innerHTML += `<div class="add-link-wrap"><a class="add-link" onclick="addListItem('specialties')">Add new</a></div>`;
}

function populateWeapons(weapons) {
    const weaponsEl = document.getElementById('weapons-content');
    let tableHtml = '<h3>Weapons</h3><table class="weapons-table"><tr><th>Name</th><th>Dmg</th><th>Range</th><th>Clip</th><th>Init</th><th>Str</th><th>Size</th><th>Special</th><th></th></tr>';
    for (const name in weapons) {
        const weapon = weapons[name];
        let range = weapon.range;
        if (typeof range === 'object') {
            range = `${range.short}/${range.medium}/${range.long}`;
        }

        // Handle special field - show tooltip link if weapon has special properties
        const tooltipContent = getWeaponSpecialTooltip(name);
        const specialHtml = tooltipContent ?
            `<span class="tooltip add-link">View<span class="tooltiptext">${tooltipContent}</span></span>` :
            '-';

        tableHtml += `<tr><td>${name}</td><td>${weapon.dmg}</td><td>${range}</td><td>${weapon.clip || '-'}</td><td>${weapon.init}</td><td>${weapon.str}</td><td>${weapon.size}</td><td>${specialHtml}</td><td><span class="delete-icon" onclick="deleteListItem('weapons', '${name}')">ðŸ—‘</span></td></tr>`;
    }
    tableHtml += '</table>';
    weaponsEl.innerHTML = tableHtml;
    weaponsEl.innerHTML += `<div class="add-link-wrap"><a class="add-link" onclick="addListItem('weapons')">Add new</a></div>`;
}

function populateSheet(data) {
    const character = data.character;

    document.getElementById('character-name-header').textContent = character.name;

    const headerContent = document.getElementById('header-content');
    headerContent.innerHTML = `
        <div class="header-item"><span>Name:</span> <span id="name" onclick="makeEditable(this, 'name')">${character.name}</span></div>
        <div class="header-item"><span>Age:</span> <span id="age" onclick="makeEditable(this, 'age')">${character.age}</span></div>
        <div class="header-item"><span>Player:</span> <span id="player" onclick="makeEditable(this, 'player')">${character.player}</span></div>
        <div class="header-item"><span>Concept:</span> <span id="concept" onclick="makeEditable(this, 'concept')">${character.concept}</span></div>
        <div class="header-item"><span>Virtue:</span> <span id="virtue" onclick="makeEditable(this, 'virtue')">${character.virtue}</span></div>
        <div class="header-item"><span>Vice:</span> <span id="vice" onclick="makeEditable(this, 'vice')">${character.vice}</span></div>
        <div class="header-item"><span>Chronicle:</span> <span id="chronicle" onclick="makeEditable(this, 'chronicle')">${character.chronicle}</span></div>
        <div class="header-item"><span>Faction:</span> <span id="faction" onclick="makeEditable(this, 'faction')">${character.faction}</span></div>
        <div class="header-item"><span>Group Name:</span> <span id="group_name" onclick="makeEditable(this, 'group_name')">${character.group_name}</span></div>
        <hr class="header-divider">
        <div class="header-item"><span>Date of Birth:</span> <span id="date_of_birth" onclick="makeEditable(this, 'description.date_of_birth')">${character.description.date_of_birth}</span></div>
        <div class="header-item"><span>Hair:</span> <span id="hair" onclick="makeEditable(this, 'description.hair')">${character.description.hair}</span></div>
        <div class="header-item"><span>Eyes:</span> <span id="eyes" onclick="makeEditable(this, 'description.eyes')">${character.description.eyes}</span></div>
        <div class="header-item"><span>Race:</span> <span id="race" onclick="makeEditable(this, 'description.race')">${character.description.race}</span></div>
        <div class="header-item"><span>Nationality:</span> <span id="nationality" onclick="makeEditable(this, 'description.nationality')">${character.description.nationality}</span></div>
        <div class="header-item"><span>Height:</span> <span id="height" onclick="makeEditable(this, 'description.height')">${character.description.height}</span></div>
        <div class="header-item"><span>Weight:</span> <span id="weight" onclick="makeEditable(this, 'description.weight')">${character.description.weight}</span></div>
        <div class="header-item"><span>Sex:</span> <span id="sex" onclick="makeEditable(this, 'description.sex')">${character.description.sex}</span></div>
        <div class="header-item"><span>Distinguishing Characteristics:</span> <span id="distinguishing_characteristics" onclick="makeEditable(this, 'description.distinguishing_characteristics')">${character.description.distinguishing_characteristics}</span></div>
    `;

    // Attributes
    const mentalAttributes = document.getElementById('mental-attributes');
    mentalAttributes.innerHTML = '<h3>Mental</h3>';
    for (const attr in character.attributes.mental) {
        mentalAttributes.innerHTML += `<div class="item"><span>${capitalizeFirstLetter(attr)}</span>${renderDots('attributes', 'mental', attr, character.attributes.mental[attr])}</div>`;
    }
    const physicalAttributes = document.getElementById('physical-attributes');
    physicalAttributes.innerHTML = '<h3>Physical</h3>';
    for (const attr in character.attributes.physical) {
        physicalAttributes.innerHTML += `<div class="item"><span>${capitalizeFirstLetter(attr)}</span>${renderDots('attributes', 'physical', attr, character.attributes.physical[attr])}</div>`;
    }
    const socialAttributes = document.getElementById('social-attributes');
    socialAttributes.innerHTML = '<h3>Social</h3>';
    for (const attr in character.attributes.social) {
        socialAttributes.innerHTML += `<div class="item"><span>${capitalizeFirstLetter(attr)}</span>${renderDots('attributes', 'social', attr, character.attributes.social[attr])}</div>`;
    }

    // Skills
    const mentalSkills = document.getElementById('mental-skills');
    mentalSkills.innerHTML = '<h3>Mental</h3>';
    for (const skill in character.skills.mental) {
        const hasSpecialty = character.specialties.hasOwnProperty(skill);
        mentalSkills.innerHTML += `<div class="item"><span><div class="specialty-box ${hasSpecialty ? 'filled' : ''}"></div>${formatSkillName(skill)}</span>${renderDots('skills', 'mental', skill, character.skills.mental[skill])}</div>`;
    }
    const physicalSkills = document.getElementById('physical-skills');
    physicalSkills.innerHTML = '<h3>Physical</h3>';
    for (const skill in character.skills.physical) {
        const hasSpecialty = character.specialties.hasOwnProperty(skill);
        physicalSkills.innerHTML += `<div class="item"><span><div class="specialty-box ${hasSpecialty ? 'filled' : ''}"></div>${formatSkillName(skill)}</span>${renderDots('skills', 'physical', skill, character.skills.physical[skill])}</div>`;
    }
    const socialSkills = document.getElementById('social-skills');
    socialSkills.innerHTML = '<h3>Social</h3>';
    for (const skill in character.skills.social) {
        const hasSpecialty = character.specialties.hasOwnProperty(skill);
        socialSkills.innerHTML += `<div class="item"><span><div class="specialty-box ${hasSpecialty ? 'filled' : ''}"></div>${formatSkillName(skill)}</span>${renderDots('skills', 'social', skill, character.skills.social[skill])}</div>`;
    }

    populateSpecialties(character.specialties);

    // Other Traits
    const healthEl = document.getElementById('health');
    healthEl.innerHTML = '<h3>Health</h3>';
    healthEl.innerHTML += renderDots('health', '', 'max', character.health.max, 10);
    if (healthDamageState.length === 0) {
        const damage = character.health.damage;
        for (let i = 0; i < damage.aggravated; i++) healthDamageState.push(3);
        for (let i = 0; i < damage.lethal; i++) healthDamageState.push(2);
        for (let i = 0; i < damage.bashing; i++) healthDamageState.push(1);
        while (healthDamageState.length < 10) healthDamageState.push(0);
    }
    healthEl.innerHTML += renderHealthDamage(healthDamageState, character.health.max);

    const willpowerEl = document.getElementById('willpower');
    willpowerEl.innerHTML = '<h3>Willpower</h3>';
    willpowerEl.innerHTML += renderDots('willpower', '', 'max', character.willpower.max, 10);
    willpowerEl.innerHTML += renderBoxes('willpower', 'current', character.willpower.current, 10, character.willpower.max);

    const integrityEl = document.getElementById('integrity');
    integrityEl.innerHTML = '<h3>Integrity</h3>';
    integrityEl.innerHTML += renderDots('integrity', '', '', character.integrity, 10);

    const tooltipContent = getBreakingPointsTooltip();
    integrityEl.innerHTML += `<div><span class="breaking-points-link tooltip" onclick="openBreakingPointsModal()">Breaking points<span class="tooltiptext">${tooltipContent}</span></span></div>`;

    const statsAndXpEl = document.getElementById('stats-and-xp');
    statsAndXpEl.innerHTML = `
        <div class="item"><span>Size:</span> <span id="size" onclick="makeEditable(this, 'size')">${character.size}</span></div>
        <div class="item"><span>Speed:</span> <span id="speed" onclick="makeEditable(this, 'speed')">${character.speed}</span></div>
        <div class="item"><span>Defense:</span> <span id="defense" onclick="makeEditable(this, 'defense')">${character.defense}</span></div>
        <div class="item"><span>Armor:</span> <span id="armor" onclick="makeEditable(this, 'armor')">${character.armor}</span></div>
        <div class="item"><span>Initiative Mod:</span> <span id="initiative_mod" onclick="makeEditable(this, 'initiative_mod')">${character.initiative_mod}</span></div>
        <h4 class="xp-subheader" onclick="openExperienceModal()">Experience</h4>
        <div class="item"><span>Beats:</span> ${renderDots('beats', '', '', character.beats, 5)}</div>
        <div class="item"><span>Total:</span> <span id="total_xp" onclick="makeEditable(this, 'experiences.total')">${character.experiences.total}</span></div>
    `;

    const conditionsEl = document.getElementById('conditions');
    conditionsEl.innerHTML = '<h3>Conditions</h3>';
    character.conditions.forEach((condition, index) => {
        const tooltipContent = getConditionTooltip(condition);
        const conditionHtml = tooltipContent ?
            `<span class="tooltip">${condition}<span class="tooltiptext">${tooltipContent}</span></span>` :
            `<span>${condition}</span>`;
        conditionsEl.innerHTML += `<div class="item">${conditionHtml}<span class="delete-icon" onclick="deleteListItem('conditions', ${index})">ðŸ—‘</span></div>`;
    });
    conditionsEl.innerHTML += `<div class="add-link-wrap"><a class="add-link" onclick="addListItem('conditions')">Add new</a></div>`;

    const aspirationsEl = document.getElementById('aspirations');
    aspirationsEl.innerHTML = '<h3>Aspirations</h3>';
    character.aspirations.forEach((aspiration, index) => {
        aspirationsEl.innerHTML += `<div class="item"><span onclick="makeAspirationEditable(this, ${index})">${aspiration}</span><span class="delete-icon" onclick="deleteListItem('aspirations', ${index})">ðŸ—‘</span></div>`;
    });
    aspirationsEl.innerHTML += `<div class="add-link-wrap"><a class="add-link" onclick="addListItem('aspirations')">Add new</a></div>`;

    populateWeapons(character.weapons);

    const equipmentEl = document.getElementById('equipment-content');
    equipmentEl.innerHTML = '<h3>Equipment</h3>';
    character.equipment.forEach((equipment, index) => {
        equipmentEl.innerHTML += `<div class="item"><span onclick="makeEquipmentEditable(this, ${index})">${equipment}</span><span class="delete-icon" onclick="deleteListItem('equipment', ${index})">ðŸ—‘</span></div>`;
    });
    equipmentEl.innerHTML += `<div class="add-link-wrap"><a class="add-link" onclick="addListItem('equipment')">Add new</a></div>`;

    // Set up merits editor (only update if merits have changed or editor is empty)
    const meritsEditor = document.getElementById('merits-editor');
    if (meritsEditor) {
        try {
            // Only update if the current editor content doesn't match the character merits
            const currentMerits = meritsEditor.is_valid() ? meritsEditor.json_value : null;
            const meritsChanged = !currentMerits || JSON.stringify(currentMerits) !== JSON.stringify(character.merits);

            if (meritsChanged) {
                meritsEditor.json_value = character.merits;
            }
        } catch (e) {
            // If there's any error with the current editor content, update it
            meritsEditor.json_value = character.merits;
        }
    }
}

function render() {
    if (characterData) {
        populateSheet(characterData);
    }
}
</script>